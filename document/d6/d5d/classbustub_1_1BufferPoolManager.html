<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>数据库系统 CMU15-445/645: bustub::BufferPoolManager类 参考</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">数据库系统 CMU15-445/645<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">CMU15-445/645 是基于现代 C++ 开发的支持并发操作的简单 SQL 操作的单机数据库</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../de/dda/namespacebustub.html">bustub</a></li><li class="navelem"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html">BufferPoolManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pri-methods">Private 成员函数</a> &#124;
<a href="#pri-attribs">Private 属性</a> &#124;
<a href="../../d3/d8f/classbustub_1_1BufferPoolManager-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">bustub::BufferPoolManager类 参考</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d4/dd6/buffer__pool__manager_8h_source.html">buffer_pool_manager.h</a>&gt;</code></p>
<div class="dynheader">
bustub::BufferPoolManager 的协作图:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/d3a/classbustub_1_1BufferPoolManager__coll__graph.svg" width="340" height="212"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="../../graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a3c648a58b96ef9dbf40ea8141dc9d9fd" id="r_a3c648a58b96ef9dbf40ea8141dc9d9fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a3c648a58b96ef9dbf40ea8141dc9d9fd">BufferPoolManager</a> (size_t pool_size, <a class="el" href="../../da/dfe/classbustub_1_1DiskManager.html">DiskManager</a> *disk_manager, size_t replacer_k=<a class="el" href="../../de/dda/namespacebustub.html#ab16ec636e3ba427ecd724fe29a554f27">LRUK_REPLACER_K</a>, <a class="el" href="../../d7/d4e/classbustub_1_1LogManager.html">LogManager</a> *log_manager=nullptr)</td></tr>
<tr class="memdesc:a3c648a58b96ef9dbf40ea8141dc9d9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html">BufferPoolManager</a>.  <br /></td></tr>
<tr class="separator:a3c648a58b96ef9dbf40ea8141dc9d9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a4623a5a510f9765e80b6277abb63" id="r_ab15a4623a5a510f9765e80b6277abb63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#ab15a4623a5a510f9765e80b6277abb63">~BufferPoolManager</a> ()</td></tr>
<tr class="memdesc:ab15a4623a5a510f9765e80b6277abb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an existing <a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html">BufferPoolManager</a>.  <br /></td></tr>
<tr class="separator:ab15a4623a5a510f9765e80b6277abb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad045f98e564811c83a121ca4de2e57d1" id="r_ad045f98e564811c83a121ca4de2e57d1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#ad045f98e564811c83a121ca4de2e57d1">GetPoolSize</a> () -&gt; size_t</td></tr>
<tr class="memdesc:ad045f98e564811c83a121ca4de2e57d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size (number of frames) of the buffer pool.  <br /></td></tr>
<tr class="separator:ad045f98e564811c83a121ca4de2e57d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e7e649475900a683770d8399618c3b" id="r_ae3e7e649475900a683770d8399618c3b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#ae3e7e649475900a683770d8399618c3b">GetPages</a> () -&gt; <a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a> *</td></tr>
<tr class="memdesc:ae3e7e649475900a683770d8399618c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to all the pages in the buffer pool.  <br /></td></tr>
<tr class="separator:ae3e7e649475900a683770d8399618c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba288b5d6dc04e952b1a1b862a75497b" id="r_aba288b5d6dc04e952b1a1b862a75497b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#aba288b5d6dc04e952b1a1b862a75497b">NewPage</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> *page_id) -&gt; <a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a> *</td></tr>
<tr class="memdesc:aba288b5d6dc04e952b1a1b862a75497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new page in the buffer pool. Set page_id to the new page's id, or nullptr if all frames are currently in use and not evictable (in another word, pinned).  <br /></td></tr>
<tr class="separator:aba288b5d6dc04e952b1a1b862a75497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b28e374c907d11086445be3e9f9b593" id="r_a7b28e374c907d11086445be3e9f9b593"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a7b28e374c907d11086445be3e9f9b593">NewPageGuarded</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> *page_id) -&gt; <a class="el" href="../../db/d3a/classbustub_1_1BasicPageGuard.html">BasicPageGuard</a></td></tr>
<tr class="memdesc:a7b28e374c907d11086445be3e9f9b593"><td class="mdescLeft">&#160;</td><td class="mdescRight">PageGuard wrapper for NewPage  <br /></td></tr>
<tr class="separator:a7b28e374c907d11086445be3e9f9b593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480106aa2e67ae966c5d76b941eee131" id="r_a480106aa2e67ae966c5d76b941eee131"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a480106aa2e67ae966c5d76b941eee131">FetchPage</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> page_id, <a class="el" href="../../de/dda/namespacebustub.html#ab8a992a575f635e8e848ddfa23fc45b3">AccessType</a> access_type=<a class="el" href="../../de/dda/namespacebustub.html#ab8a992a575f635e8e848ddfa23fc45b3a88183b946cc5f0e8c96b2e66e1c74a7e">AccessType::Unknown</a>) -&gt; <a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a> *</td></tr>
<tr class="memdesc:a480106aa2e67ae966c5d76b941eee131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the requested page from the buffer pool. Return nullptr if page_id needs to be fetched from the disk but all frames are currently in use and not evictable (in another word, pinned).  <br /></td></tr>
<tr class="separator:a480106aa2e67ae966c5d76b941eee131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e362fd4a7d8e053b36c044be06b2d4" id="r_ab0e362fd4a7d8e053b36c044be06b2d4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#ab0e362fd4a7d8e053b36c044be06b2d4">FetchPageBasic</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> page_id) -&gt; <a class="el" href="../../db/d3a/classbustub_1_1BasicPageGuard.html">BasicPageGuard</a></td></tr>
<tr class="memdesc:ab0e362fd4a7d8e053b36c044be06b2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">PageGuard wrappers for FetchPage  <br /></td></tr>
<tr class="separator:ab0e362fd4a7d8e053b36c044be06b2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cc569ad403ec55e1565297fd506cda" id="r_a32cc569ad403ec55e1565297fd506cda"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a32cc569ad403ec55e1565297fd506cda">FetchPageRead</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> page_id) -&gt; <a class="el" href="../../d8/d80/classbustub_1_1ReadPageGuard.html">ReadPageGuard</a></td></tr>
<tr class="separator:a32cc569ad403ec55e1565297fd506cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38292eb76f8f3105e7289713050025d" id="r_ab38292eb76f8f3105e7289713050025d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#ab38292eb76f8f3105e7289713050025d">FetchPageWrite</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> page_id) -&gt; <a class="el" href="../../d8/dd6/classbustub_1_1WritePageGuard.html">WritePageGuard</a></td></tr>
<tr class="separator:ab38292eb76f8f3105e7289713050025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5241ee0b5cb011b8e00d3537b53bd1" id="r_a5f5241ee0b5cb011b8e00d3537b53bd1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a5f5241ee0b5cb011b8e00d3537b53bd1">UnpinPage</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> page_id, bool is_dirty, <a class="el" href="../../de/dda/namespacebustub.html#ab8a992a575f635e8e848ddfa23fc45b3">AccessType</a> access_type=<a class="el" href="../../de/dda/namespacebustub.html#ab8a992a575f635e8e848ddfa23fc45b3a88183b946cc5f0e8c96b2e66e1c74a7e">AccessType::Unknown</a>) -&gt; bool</td></tr>
<tr class="memdesc:a5f5241ee0b5cb011b8e00d3537b53bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpin the target page from the buffer pool. If page_id is not in the buffer pool or its pin count is already 0, return false.  <br /></td></tr>
<tr class="separator:a5f5241ee0b5cb011b8e00d3537b53bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf53d6a03897fd02b0bb9f4a34de5b5" id="r_adbf53d6a03897fd02b0bb9f4a34de5b5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#adbf53d6a03897fd02b0bb9f4a34de5b5">FlushPage</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> page_id) -&gt; bool</td></tr>
<tr class="memdesc:adbf53d6a03897fd02b0bb9f4a34de5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the target page to disk.  <br /></td></tr>
<tr class="separator:adbf53d6a03897fd02b0bb9f4a34de5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3526a4b3e7aa8469cb595a2a241ffa" id="r_a2b3526a4b3e7aa8469cb595a2a241ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a2b3526a4b3e7aa8469cb595a2a241ffa">FlushAllPages</a> ()</td></tr>
<tr class="memdesc:a2b3526a4b3e7aa8469cb595a2a241ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all the pages in the buffer pool to disk.  <br /></td></tr>
<tr class="separator:a2b3526a4b3e7aa8469cb595a2a241ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886bf55926262a90d978a8a300c95acb" id="r_a886bf55926262a90d978a8a300c95acb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a886bf55926262a90d978a8a300c95acb">DeletePage</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> page_id) -&gt; bool</td></tr>
<tr class="memdesc:a886bf55926262a90d978a8a300c95acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a page from the buffer pool. If page_id is not in the buffer pool, do nothing and return true. If the page is pinned and cannot be deleted, return false immediately.  <br /></td></tr>
<tr class="separator:a886bf55926262a90d978a8a300c95acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private 成员函数</h2></td></tr>
<tr class="memitem:a28a90aa5076ce831f4cb98e7957a5ae6" id="r_a28a90aa5076ce831f4cb98e7957a5ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a28a90aa5076ce831f4cb98e7957a5ae6">WritePage</a> (<a class="el" href="../../de/dda/namespacebustub.html#a0f35ab53da3f49c3adf60f5174b16a4a">frame_id_t</a> frame_id)</td></tr>
<tr class="separator:a28a90aa5076ce831f4cb98e7957a5ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c02ff1b6299d0283bc3f200ecc83d2" id="r_a41c02ff1b6299d0283bc3f200ecc83d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a41c02ff1b6299d0283bc3f200ecc83d2">ReadPage</a> (<a class="el" href="../../de/dda/namespacebustub.html#a0f35ab53da3f49c3adf60f5174b16a4a">frame_id_t</a> frame_id)</td></tr>
<tr class="separator:a41c02ff1b6299d0283bc3f200ecc83d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888b15b62fd150bd6f2a9a56840b836e" id="r_a888b15b62fd150bd6f2a9a56840b836e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a888b15b62fd150bd6f2a9a56840b836e">AllocatePage</a> () -&gt; <a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a></td></tr>
<tr class="memdesc:a888b15b62fd150bd6f2a9a56840b836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a page on disk. Caller should acquire the latch before calling this function.  <br /></td></tr>
<tr class="separator:a888b15b62fd150bd6f2a9a56840b836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f513666877c436aa5ab22e04a4e5b38" id="r_a0f513666877c436aa5ab22e04a4e5b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a0f513666877c436aa5ab22e04a4e5b38">DeallocatePage</a> (<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> page_id)</td></tr>
<tr class="memdesc:a0f513666877c436aa5ab22e04a4e5b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate a page on disk. Caller should acquire the latch before calling this function.  <br /></td></tr>
<tr class="separator:a0f513666877c436aa5ab22e04a4e5b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private 属性</h2></td></tr>
<tr class="memitem:af402815799eb99eebb825ade628f5f71" id="r_af402815799eb99eebb825ade628f5f71"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#af402815799eb99eebb825ade628f5f71">pool_size_</a></td></tr>
<tr class="separator:af402815799eb99eebb825ade628f5f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee21e8699266207eb3c9a0ac902a4f6" id="r_abee21e8699266207eb3c9a0ac902a4f6"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#abee21e8699266207eb3c9a0ac902a4f6">next_page_id_</a> = 0</td></tr>
<tr class="separator:abee21e8699266207eb3c9a0ac902a4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145d11905d4de6a9068fab9574f7e1de" id="r_a145d11905d4de6a9068fab9574f7e1de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a145d11905d4de6a9068fab9574f7e1de">pages_</a></td></tr>
<tr class="separator:a145d11905d4de6a9068fab9574f7e1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3bb753e41055bcf0a8b74a3649a952" id="r_a2b3bb753e41055bcf0a8b74a3649a952"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="../../d1/d31/classbustub_1_1DiskScheduler.html">DiskScheduler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a2b3bb753e41055bcf0a8b74a3649a952">disk_scheduler_</a></td></tr>
<tr class="separator:a2b3bb753e41055bcf0a8b74a3649a952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed814e4a5123eeb8f3c1aa92d0f77db5" id="r_aed814e4a5123eeb8f3c1aa92d0f77db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d4e/classbustub_1_1LogManager.html">LogManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#aed814e4a5123eeb8f3c1aa92d0f77db5">log_manager_</a></td></tr>
<tr class="separator:aed814e4a5123eeb8f3c1aa92d0f77db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cde0d1bd8d7778db2c90f7177a3c71" id="r_a51cde0d1bd8d7778db2c90f7177a3c71"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>, <a class="el" href="../../de/dda/namespacebustub.html#a0f35ab53da3f49c3adf60f5174b16a4a">frame_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a51cde0d1bd8d7778db2c90f7177a3c71">page_table_</a></td></tr>
<tr class="separator:a51cde0d1bd8d7778db2c90f7177a3c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0a98a14d920f1c80ee3d9f15c52433" id="r_a0c0a98a14d920f1c80ee3d9f15c52433"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="../../d9/dc3/classbustub_1_1LRUKReplacer.html">LRUKReplacer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a0c0a98a14d920f1c80ee3d9f15c52433">replacer_</a></td></tr>
<tr class="separator:a0c0a98a14d920f1c80ee3d9f15c52433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558d64a961d0c40c29d87dcc038c5d36" id="r_a558d64a961d0c40c29d87dcc038c5d36"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="../../de/dda/namespacebustub.html#a0f35ab53da3f49c3adf60f5174b16a4a">frame_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a558d64a961d0c40c29d87dcc038c5d36">free_list_</a></td></tr>
<tr class="separator:a558d64a961d0c40c29d87dcc038c5d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29b6113b8ddfb660e08410aa4552fdb" id="r_ac29b6113b8ddfb660e08410aa4552fdb"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#ac29b6113b8ddfb660e08410aa4552fdb">latch_</a></td></tr>
<tr class="separator:ac29b6113b8ddfb660e08410aa4552fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f904d48349ff07806b46d706d44069" id="r_a70f904d48349ff07806b46d706d44069"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a70f904d48349ff07806b46d706d44069">avaliable_</a></td></tr>
<tr class="separator:a70f904d48349ff07806b46d706d44069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873eadd9aedda915be5da7e805102711" id="r_a873eadd9aedda915be5da7e805102711"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::condition_variable &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a873eadd9aedda915be5da7e805102711">cond_</a></td></tr>
<tr class="separator:a873eadd9aedda915be5da7e805102711"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p><a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html">BufferPoolManager</a> reads disk pages to and from its internal buffer pool. </p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a id="a3c648a58b96ef9dbf40ea8141dc9d9fd" name="a3c648a58b96ef9dbf40ea8141dc9d9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c648a58b96ef9dbf40ea8141dc9d9fd">&#9670;&#160;</a></span>BufferPoolManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bustub::BufferPoolManager::BufferPoolManager </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pool_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/dfe/classbustub_1_1DiskManager.html">DiskManager</a> *&#160;</td>
          <td class="paramname"><em>disk_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>replacer_k</em> = <code><a class="el" href="../../de/dda/namespacebustub.html#ab16ec636e3ba427ecd724fe29a554f27">LRUK_REPLACER_K</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d4e/classbustub_1_1LogManager.html">LogManager</a> *&#160;</td>
          <td class="paramname"><em>log_manager</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html">BufferPoolManager</a>. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool_size</td><td>the size of the buffer pool </td></tr>
    <tr><td class="paramname">disk_manager</td><td>the disk manager </td></tr>
    <tr><td class="paramname">replacer_k</td><td>the LookBack constant k for the LRU-K replacer </td></tr>
    <tr><td class="paramname">log_manager</td><td>the log manager (for testing only: nullptr = disable logging). Please ignore this for P1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab15a4623a5a510f9765e80b6277abb63" name="ab15a4623a5a510f9765e80b6277abb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15a4623a5a510f9765e80b6277abb63">&#9670;&#160;</a></span>~BufferPoolManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bustub::BufferPoolManager::~BufferPoolManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an existing <a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html">BufferPoolManager</a>. </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a888b15b62fd150bd6f2a9a56840b836e" name="a888b15b62fd150bd6f2a9a56840b836e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888b15b62fd150bd6f2a9a56840b836e">&#9670;&#160;</a></span>AllocatePage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::AllocatePage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a page on disk. Caller should acquire the latch before calling this function. </p>
<dl class="section return"><dt>返回</dt><dd>the id of the allocated page </dd></dl>

</div>
</div>
<a id="a0f513666877c436aa5ab22e04a4e5b38" name="a0f513666877c436aa5ab22e04a4e5b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f513666877c436aa5ab22e04a4e5b38">&#9670;&#160;</a></span>DeallocatePage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::BufferPoolManager::DeallocatePage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate a page on disk. Caller should acquire the latch before calling this function. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>id of the page to deallocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a886bf55926262a90d978a8a300c95acb" name="a886bf55926262a90d978a8a300c95acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886bf55926262a90d978a8a300c95acb">&#9670;&#160;</a></span>DeletePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::DeletePage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a page from the buffer pool. If page_id is not in the buffer pool, do nothing and return true. If the page is pinned and cannot be deleted, return false immediately. </p>
<p>After deleting the page from the page table, stop tracking the frame in the replacer and add the frame back to the free list. Also, reset the page's memory and metadata. Finally, you should call <a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a0f513666877c436aa5ab22e04a4e5b38" title="Deallocate a page on disk. Caller should acquire the latch before calling this function.">DeallocatePage()</a> to imitate freeing the page on the disk.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>id of page to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>false if the page exists but could not be deleted, true if the page didn't exist or deletion succeeded </dd></dl>

</div>
</div>
<a id="a480106aa2e67ae966c5d76b941eee131" name="a480106aa2e67ae966c5d76b941eee131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480106aa2e67ae966c5d76b941eee131">&#9670;&#160;</a></span>FetchPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::FetchPage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#ab8a992a575f635e8e848ddfa23fc45b3">AccessType</a>&#160;</td>
          <td class="paramname"><em>access_type</em> = <code><a class="el" href="../../de/dda/namespacebustub.html#ab8a992a575f635e8e848ddfa23fc45b3a88183b946cc5f0e8c96b2e66e1c74a7e">AccessType::Unknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the requested page from the buffer pool. Return nullptr if page_id needs to be fetched from the disk but all frames are currently in use and not evictable (in another word, pinned). </p>
<p>First search for page_id in the buffer pool. If not found, pick a replacement frame from either the free list or the replacer (always find from the free list first), read the page from disk by scheduling a read <a class="el" href="../../d7/d91/structbustub_1_1DiskRequest.html" title="Represents a Write or Read request for the DiskManager to execute.">DiskRequest</a> with disk_scheduler_-&gt;Schedule(), and replace the old page in the frame. Similar to <a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#aba288b5d6dc04e952b1a1b862a75497b" title="Create a new page in the buffer pool. Set page_id to the new page&#39;s id, or nullptr if all frames are ...">NewPage()</a>, if the old page is dirty, you need to write it back to disk and update the metadata of the new page</p>
<p>In addition, remember to disable eviction and record the access history of the frame like you did for <a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#aba288b5d6dc04e952b1a1b862a75497b" title="Create a new page in the buffer pool. Set page_id to the new page&#39;s id, or nullptr if all frames are ...">NewPage()</a>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>id of page to be fetched </td></tr>
    <tr><td class="paramname">access_type</td><td>type of access to the page, only needed for leaderboard tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>nullptr if page_id cannot be fetched, otherwise pointer to the requested page </dd></dl>
<p>在写脏页之前提前设置好是为了阻塞请求相同页的其他线程 <br  />
</p>
<p>这里就先设置好，避免释放锁的时候，请求相同页的其他线程获取到 page</p>

</div>
</div>
<a id="ab0e362fd4a7d8e053b36c044be06b2d4" name="ab0e362fd4a7d8e053b36c044be06b2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e362fd4a7d8e053b36c044be06b2d4">&#9670;&#160;</a></span>FetchPageBasic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::FetchPageBasic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; <a class="el" href="../../db/d3a/classbustub_1_1BasicPageGuard.html">BasicPageGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PageGuard wrappers for FetchPage </p>
<p>Functionality should be the same as FetchPage, except that, depending on the function called, a guard is returned. If FetchPageRead or FetchPageWrite is called, it is expected that the returned page already has a read or write latch held, respectively.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id,the</td><td>id of the page to fetch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>PageGuard holding the fetched page </dd></dl>

</div>
</div>
<a id="a32cc569ad403ec55e1565297fd506cda" name="a32cc569ad403ec55e1565297fd506cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cc569ad403ec55e1565297fd506cda">&#9670;&#160;</a></span>FetchPageRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::FetchPageRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; <a class="el" href="../../d8/d80/classbustub_1_1ReadPageGuard.html">ReadPageGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab38292eb76f8f3105e7289713050025d" name="ab38292eb76f8f3105e7289713050025d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38292eb76f8f3105e7289713050025d">&#9670;&#160;</a></span>FetchPageWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::FetchPageWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; <a class="el" href="../../d8/dd6/classbustub_1_1WritePageGuard.html">WritePageGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b3526a4b3e7aa8469cb595a2a241ffa" name="a2b3526a4b3e7aa8469cb595a2a241ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3526a4b3e7aa8469cb595a2a241ffa">&#9670;&#160;</a></span>FlushAllPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::BufferPoolManager::FlushAllPages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush all the pages in the buffer pool to disk. </p>

</div>
</div>
<a id="adbf53d6a03897fd02b0bb9f4a34de5b5" name="adbf53d6a03897fd02b0bb9f4a34de5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf53d6a03897fd02b0bb9f4a34de5b5">&#9670;&#160;</a></span>FlushPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::FlushPage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the target page to disk. </p>
<p>Use the <a class="el" href="../../da/dfe/classbustub_1_1DiskManager.html#ae89df7f59076403589c78c52482c4ceb">DiskManager::WritePage()</a> method to flush a page to disk, REGARDLESS of the dirty flag. Unset the dirty flag of the page after flushing.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>id of page to be flushed, cannot be INVALID_PAGE_ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>false if the page could not be found in the page table, true otherwise </dd></dl>

</div>
</div>
<a id="ae3e7e649475900a683770d8399618c3b" name="ae3e7e649475900a683770d8399618c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e7e649475900a683770d8399618c3b">&#9670;&#160;</a></span>GetPages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::GetPages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a> * </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the pointer to all the pages in the buffer pool. </p>

</div>
</div>
<a id="ad045f98e564811c83a121ca4de2e57d1" name="ad045f98e564811c83a121ca4de2e57d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad045f98e564811c83a121ca4de2e57d1">&#9670;&#160;</a></span>GetPoolSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::GetPoolSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; size_t </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size (number of frames) of the buffer pool. </p>

</div>
</div>
<a id="aba288b5d6dc04e952b1a1b862a75497b" name="aba288b5d6dc04e952b1a1b862a75497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba288b5d6dc04e952b1a1b862a75497b">&#9670;&#160;</a></span>NewPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::NewPage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> *&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; <a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new page in the buffer pool. Set page_id to the new page's id, or nullptr if all frames are currently in use and not evictable (in another word, pinned). </p>
<p>You should pick the replacement frame from either the free list or the replacer (always find from the free list first), and then call the <a class="el" href="../../d6/d5d/classbustub_1_1BufferPoolManager.html#a888b15b62fd150bd6f2a9a56840b836e" title="Allocate a page on disk. Caller should acquire the latch before calling this function.">AllocatePage()</a> method to get a new page id. If the replacement frame has a dirty page, you should write it back to the disk first. You also need to reset the memory and metadata for the new page.</p>
<p>Remember to "Pin" the frame by calling replacer.SetEvictable(frame_id, false) so that the replacer wouldn't evict the frame before the buffer pool manager "Unpin"s it. Also, remember to record the access history of the frame in the replacer for the lru-k algorithm to work.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">page_id</td><td>id of created page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>nullptr if no new pages could be created, otherwise pointer to new page </dd></dl>

</div>
</div>
<a id="a7b28e374c907d11086445be3e9f9b593" name="a7b28e374c907d11086445be3e9f9b593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b28e374c907d11086445be3e9f9b593">&#9670;&#160;</a></span>NewPageGuarded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::NewPageGuarded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a> *&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; <a class="el" href="../../db/d3a/classbustub_1_1BasicPageGuard.html">BasicPageGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PageGuard wrapper for NewPage </p>
<p>Functionality should be the same as NewPage, except that instead of returning a pointer to a page, you return a <a class="el" href="../../db/d3a/classbustub_1_1BasicPageGuard.html">BasicPageGuard</a> structure.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">page_id,the</td><td>id of the new page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="../../db/d3a/classbustub_1_1BasicPageGuard.html">BasicPageGuard</a> holding a new page </dd></dl>

</div>
</div>
<a id="a41c02ff1b6299d0283bc3f200ecc83d2" name="a41c02ff1b6299d0283bc3f200ecc83d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c02ff1b6299d0283bc3f200ecc83d2">&#9670;&#160;</a></span>ReadPage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::BufferPoolManager::ReadPage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a0f35ab53da3f49c3adf60f5174b16a4a">frame_id_t</a>&#160;</td>
          <td class="paramname"><em>frame_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f5241ee0b5cb011b8e00d3537b53bd1" name="a5f5241ee0b5cb011b8e00d3537b53bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5241ee0b5cb011b8e00d3537b53bd1">&#9670;&#160;</a></span>UnpinPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::UnpinPage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_dirty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#ab8a992a575f635e8e848ddfa23fc45b3">AccessType</a>&#160;</td>
          <td class="paramname"><em>access_type</em> = <code><a class="el" href="../../de/dda/namespacebustub.html#ab8a992a575f635e8e848ddfa23fc45b3a88183b946cc5f0e8c96b2e66e1c74a7e">AccessType::Unknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpin the target page from the buffer pool. If page_id is not in the buffer pool or its pin count is already 0, return false. </p>
<p>Decrement the pin count of a page. If the pin count reaches 0, the frame should be evictable by the replacer. Also, set the dirty flag on the page to indicate if the page was modified.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>id of page to be unpinned </td></tr>
    <tr><td class="paramname">is_dirty</td><td>true if the page should be marked as dirty, false otherwise </td></tr>
    <tr><td class="paramname">access_type</td><td>type of access to the page, only needed for leaderboard tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>false if the page is not in the page table or its pin count is &lt;= 0 before this call, true otherwise </dd></dl>

</div>
</div>
<a id="a28a90aa5076ce831f4cb98e7957a5ae6" name="a28a90aa5076ce831f4cb98e7957a5ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a90aa5076ce831f4cb98e7957a5ae6">&#9670;&#160;</a></span>WritePage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::BufferPoolManager::WritePage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dda/namespacebustub.html#a0f35ab53da3f49c3adf60f5174b16a4a">frame_id_t</a>&#160;</td>
          <td class="paramname"><em>frame_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="a70f904d48349ff07806b46d706d44069" name="a70f904d48349ff07806b46d706d44069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f904d48349ff07806b46d706d44069">&#9670;&#160;</a></span>avaliable_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; bustub::BufferPoolManager::avaliable_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>控制是否已经读取好数据 </p>

</div>
</div>
<a id="a873eadd9aedda915be5da7e805102711" name="a873eadd9aedda915be5da7e805102711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873eadd9aedda915be5da7e805102711">&#9670;&#160;</a></span>cond_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::condition_variable&gt; bustub::BufferPoolManager::cond_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b3bb753e41055bcf0a8b74a3649a952" name="a2b3bb753e41055bcf0a8b74a3649a952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3bb753e41055bcf0a8b74a3649a952">&#9670;&#160;</a></span>disk_scheduler_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="../../d1/d31/classbustub_1_1DiskScheduler.html">DiskScheduler</a>&gt; bustub::BufferPoolManager::disk_scheduler_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the disk sheduler. </p>

</div>
</div>
<a id="a558d64a961d0c40c29d87dcc038c5d36" name="a558d64a961d0c40c29d87dcc038c5d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558d64a961d0c40c29d87dcc038c5d36">&#9670;&#160;</a></span>free_list_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="../../de/dda/namespacebustub.html#a0f35ab53da3f49c3adf60f5174b16a4a">frame_id_t</a>&gt; bustub::BufferPoolManager::free_list_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of free frames that don't have any pages on them. </p>

</div>
</div>
<a id="ac29b6113b8ddfb660e08410aa4552fdb" name="ac29b6113b8ddfb660e08410aa4552fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29b6113b8ddfb660e08410aa4552fdb">&#9670;&#160;</a></span>latch_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex bustub::BufferPoolManager::latch_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This latch protects shared data structures. We recommend updating this comment to describe what it protects. </p>

</div>
</div>
<a id="aed814e4a5123eeb8f3c1aa92d0f77db5" name="aed814e4a5123eeb8f3c1aa92d0f77db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed814e4a5123eeb8f3c1aa92d0f77db5">&#9670;&#160;</a></span>log_manager_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d4e/classbustub_1_1LogManager.html">LogManager</a>* bustub::BufferPoolManager::log_manager_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the log manager. Please ignore this for P1. </p>

</div>
</div>
<a id="abee21e8699266207eb3c9a0ac902a4f6" name="abee21e8699266207eb3c9a0ac902a4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee21e8699266207eb3c9a0ac902a4f6">&#9670;&#160;</a></span>next_page_id_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>&gt; bustub::BufferPoolManager::next_page_id_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The next page id to be allocated <br  />
 </p>

</div>
</div>
<a id="a51cde0d1bd8d7778db2c90f7177a3c71" name="a51cde0d1bd8d7778db2c90f7177a3c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cde0d1bd8d7778db2c90f7177a3c71">&#9670;&#160;</a></span>page_table_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="../../de/dda/namespacebustub.html#a8de4ac099b23d712481109bb846decde">page_id_t</a>, <a class="el" href="../../de/dda/namespacebustub.html#a0f35ab53da3f49c3adf60f5174b16a4a">frame_id_t</a>&gt; bustub::BufferPoolManager::page_table_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a> table for keeping track of buffer pool pages. </p>

</div>
</div>
<a id="a145d11905d4de6a9068fab9574f7e1de" name="a145d11905d4de6a9068fab9574f7e1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145d11905d4de6a9068fab9574f7e1de">&#9670;&#160;</a></span>pages_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d87/classbustub_1_1Page.html">Page</a>* bustub::BufferPoolManager::pages_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of buffer pool pages. </p>

</div>
</div>
<a id="af402815799eb99eebb825ade628f5f71" name="af402815799eb99eebb825ade628f5f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af402815799eb99eebb825ade628f5f71">&#9670;&#160;</a></span>pool_size_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t bustub::BufferPoolManager::pool_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of pages in the buffer pool. </p>

</div>
</div>
<a id="a0c0a98a14d920f1c80ee3d9f15c52433" name="a0c0a98a14d920f1c80ee3d9f15c52433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0a98a14d920f1c80ee3d9f15c52433">&#9670;&#160;</a></span>replacer_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="../../d9/dc3/classbustub_1_1LRUKReplacer.html">LRUKReplacer</a>&gt; bustub::BufferPoolManager::replacer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="../../de/dda/classbustub_1_1Replacer.html">Replacer</a> to find unpinned pages for replacement. </p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>src/include/buffer/<a class="el" href="../../d4/dd6/buffer__pool__manager_8h_source.html">buffer_pool_manager.h</a></li>
<li>src/buffer/<a class="el" href="../../d2/d67/buffer__pool__manager_8cpp.html">buffer_pool_manager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
